import * as tslib_1 from "tslib";
import { Pipe, LOCALE_ID, Inject } from '@angular/core';
import { CalendarDateFormatter, DateAdapter } from 'angular-calendar';
var CalendarSchedulerDatePipe = /** @class */ (function () {
    function CalendarSchedulerDatePipe(dateAdapter, dateFormatter, locale) {
        this.dateAdapter = dateAdapter;
        this.dateFormatter = dateFormatter;
        this.locale = locale;
    }
    CalendarSchedulerDatePipe.prototype.transform = function (date, method, locale, weekStartsOn, excludeDays, daysInWeek, startsWithToday) {
        if (locale === void 0) { locale = this.locale; }
        if (weekStartsOn === void 0) { weekStartsOn = 0; }
        if (excludeDays === void 0) { excludeDays = []; }
        if (typeof this.dateFormatter[method] === 'undefined') {
            var allowedMethods = Object.getOwnPropertyNames(Object.getPrototypeOf(CalendarDateFormatter.prototype)).filter(function (iMethod) { return iMethod !== 'constructor'; });
            throw new Error(method + " is not a valid date formatter. Can only be one of " + allowedMethods.join(', '));
        }
        return this.dateFormatter[method]({
            dateAdapter: this.dateAdapter,
            date: date,
            locale: locale,
            weekStartsOn: weekStartsOn,
            excludeDays: excludeDays,
            daysInWeek: daysInWeek,
            startsWithToday: startsWithToday
        });
    };
    CalendarSchedulerDatePipe.ctorParameters = function () { return [
        { type: DateAdapter },
        { type: CalendarDateFormatter },
        { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
    ]; };
    CalendarSchedulerDatePipe = tslib_1.__decorate([
        Pipe({
            name: 'calendarSchedulerDate'
        }),
        tslib_1.__param(2, Inject(LOCALE_ID))
    ], CalendarSchedulerDatePipe);
    return CalendarSchedulerDatePipe;
}());
export { CalendarSchedulerDatePipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXItc2NoZWR1bGVyLWRhdGUucGlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItY2FsZW5kYXItc2NoZWR1bGVyLyIsInNvdXJjZXMiOlsibW9kdWxlcy9zY2hlZHVsZXIvcGlwZXMvY2FsZW5kYXItc2NoZWR1bGVyLWRhdGUucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLElBQUksRUFBaUIsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN2RSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsV0FBVyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFLdEU7SUFDRSxtQ0FDVSxXQUF3QixFQUN4QixhQUFvQyxFQUNqQixNQUFjO1FBRmpDLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQ3hCLGtCQUFhLEdBQWIsYUFBYSxDQUF1QjtRQUNqQixXQUFNLEdBQU4sTUFBTSxDQUFRO0lBQ3hDLENBQUM7SUFFSiw2Q0FBUyxHQUFULFVBQ0UsSUFBVSxFQUNWLE1BQWMsRUFDZCxNQUE0QixFQUM1QixZQUF3QixFQUN4QixXQUEwQixFQUMxQixVQUFtQixFQUNuQixlQUF5QjtRQUp6Qix1QkFBQSxFQUFBLFNBQWlCLElBQUksQ0FBQyxNQUFNO1FBQzVCLDZCQUFBLEVBQUEsZ0JBQXdCO1FBQ3hCLDRCQUFBLEVBQUEsZ0JBQTBCO1FBSTFCLElBQUksT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxLQUFLLFdBQVcsRUFBRTtZQUNyRCxJQUFNLGNBQWMsR0FBRyxNQUFNLENBQUMsbUJBQW1CLENBQy9DLE1BQU0sQ0FBQyxjQUFjLENBQUMscUJBQXFCLENBQUMsU0FBUyxDQUFDLENBQ3ZELENBQUMsTUFBTSxDQUFDLFVBQUEsT0FBTyxJQUFJLE9BQUEsT0FBTyxLQUFLLGFBQWEsRUFBekIsQ0FBeUIsQ0FBQyxDQUFDO1lBQy9DLE1BQU0sSUFBSSxLQUFLLENBQ1YsTUFBTSwyREFBc0QsY0FBYyxDQUFDLElBQUksQ0FDaEYsSUFBSSxDQUNILENBQ0osQ0FBQztTQUNIO1FBQ0QsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2hDLFdBQVcsRUFBRSxJQUFJLENBQUMsV0FBVztZQUM3QixJQUFJLE1BQUE7WUFDSixNQUFNLFFBQUE7WUFDTixZQUFZLGNBQUE7WUFDWixXQUFXLGFBQUE7WUFDWCxVQUFVLFlBQUE7WUFDVixlQUFlLGlCQUFBO1NBQ2hCLENBQUMsQ0FBQztJQUNMLENBQUM7O2dCQWpDc0IsV0FBVztnQkFDVCxxQkFBcUI7NkNBQzNDLE1BQU0sU0FBQyxTQUFTOztJQUpSLHlCQUF5QjtRQUhyQyxJQUFJLENBQUM7WUFDSixJQUFJLEVBQUUsdUJBQXVCO1NBQzlCLENBQUM7UUFLRyxtQkFBQSxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUE7T0FKVCx5QkFBeUIsQ0FvQ3JDO0lBQUQsZ0NBQUM7Q0FBQSxBQXBDRCxJQW9DQztTQXBDWSx5QkFBeUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtLCBMT0NBTEVfSUQsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDYWxlbmRhckRhdGVGb3JtYXR0ZXIsIERhdGVBZGFwdGVyIH0gZnJvbSAnYW5ndWxhci1jYWxlbmRhcic7XHJcblxyXG5AUGlwZSh7XHJcbiAgbmFtZTogJ2NhbGVuZGFyU2NoZWR1bGVyRGF0ZSdcclxufSlcclxuZXhwb3J0IGNsYXNzIENhbGVuZGFyU2NoZWR1bGVyRGF0ZVBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgZGF0ZUFkYXB0ZXI6IERhdGVBZGFwdGVyLFxyXG4gICAgcHJpdmF0ZSBkYXRlRm9ybWF0dGVyOiBDYWxlbmRhckRhdGVGb3JtYXR0ZXIsXHJcbiAgICBASW5qZWN0KExPQ0FMRV9JRCkgcHJpdmF0ZSBsb2NhbGU6IHN0cmluZ1xyXG4gICkge31cclxuXHJcbiAgdHJhbnNmb3JtKFxyXG4gICAgZGF0ZTogRGF0ZSxcclxuICAgIG1ldGhvZDogc3RyaW5nLFxyXG4gICAgbG9jYWxlOiBzdHJpbmcgPSB0aGlzLmxvY2FsZSxcclxuICAgIHdlZWtTdGFydHNPbjogbnVtYmVyID0gMCxcclxuICAgIGV4Y2x1ZGVEYXlzOiBudW1iZXJbXSA9IFtdLFxyXG4gICAgZGF5c0luV2Vlaz86IG51bWJlcixcclxuICAgIHN0YXJ0c1dpdGhUb2RheT86IGJvb2xlYW5cclxuICApOiBzdHJpbmcge1xyXG4gICAgaWYgKHR5cGVvZiB0aGlzLmRhdGVGb3JtYXR0ZXJbbWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgY29uc3QgYWxsb3dlZE1ldGhvZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhcclxuICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2FsZW5kYXJEYXRlRm9ybWF0dGVyLnByb3RvdHlwZSlcclxuICAgICAgKS5maWx0ZXIoaU1ldGhvZCA9PiBpTWV0aG9kICE9PSAnY29uc3RydWN0b3InKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGAke21ldGhvZH0gaXMgbm90IGEgdmFsaWQgZGF0ZSBmb3JtYXR0ZXIuIENhbiBvbmx5IGJlIG9uZSBvZiAke2FsbG93ZWRNZXRob2RzLmpvaW4oXHJcbiAgICAgICAgICAnLCAnXHJcbiAgICAgICAgKX1gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5kYXRlRm9ybWF0dGVyW21ldGhvZF0oe1xyXG4gICAgICBkYXRlQWRhcHRlcjogdGhpcy5kYXRlQWRhcHRlcixcclxuICAgICAgZGF0ZSxcclxuICAgICAgbG9jYWxlLFxyXG4gICAgICB3ZWVrU3RhcnRzT24sXHJcbiAgICAgIGV4Y2x1ZGVEYXlzLFxyXG4gICAgICBkYXlzSW5XZWVrLFxyXG4gICAgICBzdGFydHNXaXRoVG9kYXlcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4iXX0=